/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
struct sig_std_logic_funcs {
    boolean_or_set: ::std::option::Option<unsafe extern "C" fn(_cpssp:
                                                               *mut ::std::os::raw::c_void,
                                                               val:
                                                               ::std::os::raw::c_uint)>,
    std_logic_set: ::std::option::Option<unsafe extern "C" fn(_cpssp:
                                                              *mut ::std::os::raw::c_void,
                                                              val:
                                                              ::std::os::raw::c_uint)>,
    std_logic_setN: ::std::option::Option<unsafe extern "C" fn(_cpssp:
                                                               *mut ::std::os::raw::c_void,
                                                               n:
                                                               ::std::os::raw::c_int,
                                                               val:
                                                               ::std::os::raw::c_uint)>,
    set_ext: ::std::option::Option<unsafe extern "C" fn(_cpssp:
                                                        *mut WireData,
                                                        val: u32)>,
    set_extN: ::std::option::Option<unsafe extern "C" fn(_cpssp:
                                                         *mut ::std::os::raw::c_void,
                                                         n:
                                                         ::std::os::raw::c_int,
                                                         val:
                                                         ::std::os::raw::c_uint)>,
    consume: ::std::option::Option<unsafe extern "C" fn(_cpssp:
                                                        *mut ::std::os::raw::c_void,
                                                        energy: f64)>,
    supply: ::std::option::Option<unsafe extern "C" fn(_cpssp:
                                                       *mut ::std::os::raw::c_void)
                                                       -> f64>,
    supply_ext: ::std::option::Option<unsafe extern "C" fn(_cpssp:
                                                           *mut ::std::os::raw::c_void)
                                                           -> f64>,
}
impl ::std::default::Default for sig_std_logic_funcs {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct sig_std_logic {
    name: *mut ::std::os::raw::c_char,
    in_: [Struct_Unnamed1; 32usize],
    in_count: ::std::os::raw::c_uint,
    out: [Struct_Unnamed2; 32usize],
    out_count: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
struct Struct_Unnamed1 {
    s: *mut ::std::os::raw::c_void,
    f: *const sig_std_logic_funcs,
    n: ::std::os::raw::c_int,
    in_: ::std::os::raw::c_uint,
    energy: f64,
}
impl ::std::default::Default for Struct_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
struct Struct_Unnamed2 {
    s: *mut ::std::os::raw::c_void,
    out: ::std::os::raw::c_uint,
}
impl ::std::default::Default for Struct_Unnamed2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
struct sig_std_logic_merge {
    s0: *mut sig_std_logic,
    s1: *mut sig_std_logic,
}
impl ::std::default::Default for sig_std_logic_merge {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    fn sig_std_logic_resolve(val0: ::std::os::raw::c_uint,
                                 val1: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
    fn sig_std_logic_set(b: *mut sig_std_logic,
                             s: *const WireData,
                             val: ::std::os::raw::c_uint);
    fn sig_std_logic_or_set(b: *mut sig_std_logic,
                                s: *mut ::std::os::raw::c_void,
                                val: ::std::os::raw::c_uint);
    fn sig_std_logic_consume(sig: *mut sig_std_logic,
                                 s: *mut ::std::os::raw::c_void, energy: f64);
    fn sig_std_logic_supply(sig: *mut sig_std_logic,
                                s: *mut ::std::os::raw::c_void) -> f64;
    fn sig_std_logic_connect_in(b: *mut sig_std_logic,
                                    s: *const WireData,
                                    f: *const sig_std_logic_funcs);
    fn sig_std_logic_connect_inN(b: *mut sig_std_logic,
                                     s: *mut ::std::os::raw::c_void,
                                     n: ::std::os::raw::c_int,
                                     f: *const sig_std_logic_funcs);
    fn sig_std_logic_connect_out(b: *mut sig_std_logic,
                                     s: *const WireData,
                                     val: ::std::os::raw::c_uint);
    fn sig_std_logic_merge(s0: *mut sig_std_logic, s1: *mut sig_std_logic)
     -> *mut sig_std_logic_merge;
    fn sig_std_logic_split(m: *mut sig_std_logic_merge);
    fn sig_std_logic_create(name: *const ::std::os::raw::c_char)
     -> *mut sig_std_logic;
    fn sig_std_logic_destroy(sig: *mut sig_std_logic);
}


// rust code
use std::ffi::CString;
use std::mem;
use std::ptr;
use std::ops::Deref;

pub const LOGIC_0: u32 = ((0 & 0xffff) << 0) | (0xffff << 16);
pub const LOGIC_1: u32 = ((5000 & 0xffff) << 0) | ( 0xffff << 16);
pub const LOGIC_Z: u32 = 0xffff;
pub const LOGIC_H: u32 = ((5000 & 0xffff) << 0) | ( 1 << 16);

static ext_data: WireData = WireData { mv: 0 };

#[repr(C)]
struct WireData {
    mv: u16
}

pub struct Wire {
    logic: *mut sig_std_logic,
    // we need a constant address, so we cannot allocate this on the stack
    // because it may be moved there
    data: Box<WireData>,
    // same as above
    funcs: Box<sig_std_logic_funcs>
}

impl Wire {
    pub fn new() -> Wire {
        unsafe {
            let funcs = Box::new(sig_std_logic_funcs {
                boolean_or_set: None,
                consume: None,
                set_ext: Some(wire_set_cb),
                set_extN: None,
                std_logic_set: None,
                std_logic_setN: None,
                supply: None,
                supply_ext: None,
            });
            let mut w = Wire {
                logic: sig_std_logic_create(CString::new("wire").unwrap().as_ptr()),
                data: Box::new(WireData {mv: 0}),
                funcs: funcs
            };
            sig_std_logic_connect_out(w.logic, &ext_data, LOGIC_Z);
            sig_std_logic_connect_out(w.logic, &mut w.data as &mut WireData, LOGIC_Z);
            sig_std_logic_connect_in(w.logic, &mut w.data as &mut WireData, &mut w.funcs as &mut sig_std_logic_funcs);
            w
        }
    }

    #[inline]
    pub fn set(&self, value: u32) {
        unsafe {
            sig_std_logic_set(self.logic, &self.data as &WireData, value);
        }
    }

    // this function is needed, if the value should be read back from the cpu itself
    // because the own value is ignored, when calculating the value of the wire
    #[inline]
    pub fn set_ext(&self, value: u32) {
        unsafe {
            sig_std_logic_set(self.logic, &ext_data, value);
        }
    }

    #[inline]
    pub fn set_bool(&self, value: bool) {
        self.set(if value {LOGIC_1} else {LOGIC_0});
    }

    #[inline]
    pub fn mv(&self) -> u16 {
        self.data.mv
    }

    #[inline]
    pub fn as_bin(&self) -> u8 {
        (self.mv() > 2500) as u8
    }
}

unsafe extern "C" fn wire_set_cb(data: *mut WireData, value: u32) {
    (*data).mv = value as u16;
    println!("New mV: {}", (*data).mv);
}

impl Deref for Wire {
    type Target = sig_std_logic;

    fn deref(&self) -> &sig_std_logic {
        unsafe { &*self.logic as &sig_std_logic}
    }
}

impl Drop for Wire {
    fn drop(&mut self) {
        unsafe {
            sig_std_logic_destroy(self.logic);
        }
    }
}

pub struct IO {
    pub nreset: Wire,
    pub vcc: Wire,
    pub gnd: Wire,
    pub p: [[Wire; 8]; 4]
}

impl IO {
    pub fn new() -> IO {
        // see http://stackoverflow.com/a/31361031
        let mut p: [[Wire; 8]; 4] = unsafe { [mem::uninitialized(),
                                              mem::uninitialized(),
                                              mem::uninitialized(),
                                              mem::uninitialized()] };
        for outer in p.iter_mut() {
            for elem in outer.iter_mut() {
                unsafe {
                    ptr::write(elem, Wire::new());
                }
            }
        }

        IO {
            nreset: Wire::new(),
            vcc: Wire::new(),
            gnd: Wire::new(),
            p: p
        }
    }
}
